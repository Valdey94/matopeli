/*
 * Kurssi: Lausekielinen ohjelmointi (Laki/TIEP1)
 * Syksy 2013.
 *
 * Koodin tekijä: Valtteri Ylisalo
 * Opiskelijanumero: a618968
 * Sähköpostiosoite: a618968@student.uta.fi
 *
 * Harjoitustyö 2:
 * Java-ohjelma, joka on matopelin tekstipohjainen variaatio.
 */


public class Matopeli {


  // Vakioidut madon merkit.
  public static final char PAA = 'X';
  public static final char KAULA = 'x';
  public static final char KEHO = 'o';

  // Vakioidut kentän merkit.
  public static final char TAUSTA = ' ';
  public static final char SEINA = '.';
  public static final char RUOKA = '+';

  // Vakioidut valinnat.
  public static final char LEFT = 'l';
  public static final char RIGHT = 'r';
  public static final char UP = 'u';
  public static final char DOWN = 'd';
  public static final char SWAP = 's';
  public static final char QUIT = 'q';


  /* Päämetodi. Ohjelman suoritus alkaa tästä lohkosta.
   */
  public static void main(String[] args) {
    // Tulostetaan matomerkeillä kehystetty viesti ohjelman käynnistyessä.
    System.out.println("~~~~~~~~~~~\n~ W O R M ~\n~~~~~~~~~~~");

    // Siemenluku, jolla ruokaa saadaan kentälle Automaatti-apuluokan avulla.
    int siemen = 0;
    
    // Kentän rivien lukumäärä.
    int riviLkm = 0;

    // Kentän sarakkeiden lukumäärä.
    int sarakeLkm = 0;

    // Syötteiden oikeellisuus. Alustavasti oletetaan niiden olevan järkevät.
    boolean syoteOK = true;

    // Komentoriviparametrejä täytyy olla tasan kolme.
    if (args.length == 3) {
      // Yritetään muuntaa annetut komentoriviparametrit kokonaisluvuiksi.
      try {
        siemen = Integer.parseInt(args[0]);
        riviLkm = Integer.parseInt(args[1]);
        sarakeLkm = Integer.parseInt(args[2]);
      }
      // Komentoriviparametrien tyypit olivat virheellisiä.
      catch (NumberFormatException e) {
        syoteOK = false;
      }
    }
    // Muutoin syötteet eivät kelpaa.
    else
      syoteOK = false;

    // Tarkistetaan vielä, että rivejä ja sarakkeita ei ole liian vähän.
    if (riviLkm < 3 || sarakeLkm < 7)
      syoteOK = false;

    // Kutsutaan matopeliä mallintavaa metodia vain, jos syötteet hyväksyttiin.
    if (syoteOK)
      mallinnaPelia(siemen, riviLkm, sarakeLkm);
    // Muutoin mallintamista ei edes yritetä, ja annetaan virheestä ilmoitus.
    else
      System.out.println("Invalid command-line argument!");

    // Peli loppui. Tämä tulostetaan aina ohjelman loppuessa.
    System.out.println("Bye, see you soon.");
  }


  /* Mallintaa matopeliä. Ensiksi luodaan viidestä merkistä koostuva mato.
   * Sen jälkeen luodaan pelikenttä, jonka rivien ja sarakkeiden lukumäärät
   * annettiin päämetodissa. Automaatti-apuluokan avulla kenttään sijoitetaan
   * tarvittaessa ruokaa. Peliä pelataan niin kauan kuin mato elää. Mato kuolee, 
   * jos 1) valitaan lopeta-toiminto, 2) tekee seiniin neljä reikää, 3) törmää
   * itseensä. Jokaisen siirron jälkeen näytölle päivitetään kuvio, jossa
   * sijaitsee mato, ruoka ja pelikenttä. Pelin loppumisen jälkeen palataan
   * main-metodiin.
   */
  public static void mallinnaPelia(int siemen, int riviLkm, int sarakeLkm) {
    // Esitellään, luodaan ja alustetaan taulukko-olio, jossa on madon paikat.
    int[][] paikat = { {1, 5},
                       {1, 4},
                       {1, 3},
                       {1, 2},
                       {1, 1} };

    // Alustavasti mato on elossa. Tämä apumuuttuja helpottaa pelaamista.
    boolean matoElossa = true;

    // Kutsutaan metodia, joka luo kenttätaulukon.
    char[][] kentta = luoTaulukko(riviLkm, sarakeLkm);

    // Kutsutaan metodia, joka piirtää kuvion ennen pelin aloittamista.
    boolean piirtoOK = piirraKuvio(kentta, paikat);

    // Kutsutaan apuluokkaa, joka käynnistää ruoka-automaatin.
    Automaatti.kaynnista(siemen);

    // Jotta ruokaa saadaan helpommin tarjoiltua heti kentälle, päätetään
    // että mato söi ruokaa juuri ennen pelin alkamista.
    boolean syotiinRuokaa = true;

    // Pelataan niin kauan kuin mato elää.
    while (matoElossa) {

      // Jos viime kierroksella syötiin ruokaa, kutsutaan apuluokkaa, joka
      // sijoittaa ruokaa kentälle.
      if (syotiinRuokaa)
        Automaatti.tarjoile(kentta);

      // Kutsutaan metodia, joka laskee seiniin tehtyjen reikien määrän.
      int reikia = laskeMadonreikia(kentta);
      // Jos reikiä oli enemmän kuin kolme, madolta lähtee henki.
      if (reikia > 3)
        matoElossa = false;

      // Jatketaan peliä vain, jos madolta ei lähtenyt henki reikiä tehdessä.
      if (matoElossa) {
        // Tulostetaan tilannerivi: Madon pituus ja madon tekemien reikien määrä.
        System.out.println("Worm length: "+paikat.length+", wormholes: "+reikia+".");

        // Jos piirto onnistui viime kierroksella, jatketaan.
        if (piirtoOK) {
          // Kutsutaan metodia, joka tulostaa kentän näytölle.
          tulosta(kentta);

          // Päivitetään mato oikeelliseksi niin, että häntä ei veny liian pitkäksi.
          if (kentta[paikat[paikat.length - 1][0]][paikat[paikat.length - 1][1]] == 'o')
            kentta[paikat[paikat.length - 1][0]][paikat[paikat.length - 1][1]] = ' ';

          // Infotaan toiminnot käyttäjälle ja luetaan valinta In-apuluokan avulla.
          System.out.println("(l)eft, (r)ight, (u)p, (d)own, (s)wap or (q)uit?");
          char valinta = In.readChar();

          // Jos halutaan lopettaa, madolta lähtee henki ja peli päättyy.
          if (valinta == QUIT)
            matoElossa = false;

          // Muutoin jatketaan peliä.
          else {
            // Tallennetaan hännän paikkatiedot muistiin madon kasvamisen varalta.
            int hantaRivi = paikat[paikat.length - 1][0];
            int hantaSarake = paikat[paikat.length - 1][1];

            // Kutsutaan metodia, joka liikuttaa matoa.
            paikat = liikutaMatoa(paikat, valinta, kentta);

            // Kutsutaan metodia, joka tarkistaa törmäsikö mato itseensä.
            matoElossa = tarkistaTormays(paikat);

            // Kutsutaan metodia, joka tarkistaa syötiinkö ruokaa.
            syotiinRuokaa = tarkistaRuoka(paikat, kentta);

            // Jos madon pää siirtyi ruokaan, kutsutaan metodia joka kasvattaa matoa.
            if (syotiinRuokaa)
              paikat = kasvataMatoa(paikat, hantaRivi, hantaSarake);

            // Jos mato on elossa, kutsutaan metodia joka piirtää pelikentän,
            // jossa on päivitetyt kenttätiedot ja madon paikkatiedot.
            if (matoElossa)
              piirtoOK = piirraKuvio(kentta, paikat);
          }
        }
      }
    }
  }


  /* Luo annetun kokoisen taulukon, alustaa sen ja palauttaa viitteen.
   */
  public static char[][] luoTaulukko(int riviLkm, int sarakeLkm) {
    // Esitellään viite, varataan taulukko-oliolle muistia ja liitetään siihe viite.
    char[][] kentta = new char[riviLkm][sarakeLkm];
    // Kutsutaan metodia, joka alustaa taulukon kentäksi.
    alustaTaulukko(kentta, '.', ' ');
    // Palautetaan viite taulukkoon.
    return kentta;
  }


  /* Alustaa kaksiulotteisen kenttätaulukon siten, että taulukon reunoille
   * sijoitetaan merkki a ja taulukon sisäalkioihin sijoitetaan merkki b.
   */
  public static void alustaTaulukko(char[][] kentta, char a, char b) {
    // Käsitellään taulukkoa vain, jos sille on varattu muistia.
    if (kentta != null) {
      // Asetetaan jompikumpi merkki kuhunkin taulukon alkioon.
      for (int rivi = 0; rivi < kentta.length; rivi++)
        for (int sarake = 0; sarake < kentta[0].length; sarake++)
         // Reuna-alkio.
         if (rivi == 0 || rivi == kentta.length - 1 || sarake == 0
             || sarake == kentta[0].length - 1)
           kentta[rivi][sarake] = a;
         // Sisäalkio.
         else
           kentta[rivi][sarake] = b;
    }
  }


  /* Piirtää kuvion merkit annettuihin merkkitaulukon paikkoihin. Merkki
   * määräytyy paikkatietojen mukaan. Paluuarvona piirtämisen onnistuminen.
   */
  public static boolean piirraKuvio(char[][] kentta, int[][] paikat) {
    // Piirretään vain, jos molemmat taulukot ovat saatavilla.
    if (kentta != null && paikat != null) {
      // Sijoitetaan kuvion merkit kenttään lukumäärän verran.
      for (int paikanInd = 0; paikanInd < paikat.length; paikanInd++) {
        // Kuvion merkin rivi- ja sarakeindeksit.
        int merkinRivInd = paikat[paikanInd][0];
        int merkinSarInd = paikat[paikanInd][1];
        
        // Asetetaan sopiva piirtomerkki merkkikentän paikkaan indeksin mukaan.
        if (paikanInd == 0)
          // Madon pää.
          kentta[merkinRivInd][merkinSarInd] = PAA;
        else if (paikanInd == 1)
          // Madon kaula.
          kentta[merkinRivInd][merkinSarInd] = KAULA;
        else if (paikanInd < paikat.length)
          // Madon kehon palanen.
          kentta[merkinRivInd][merkinSarInd] = KEHO;
          // Tyhjää taustaa.
        else
          kentta[merkinRivInd][merkinSarInd] = TAUSTA;
      }
      
      // Piirto onnistui.
      return true;

    }
    // Muutoin piirto epäonnistuu, jos taulukoille ei oltu varattu muistia.
    else
      return false;
  }


  /* Tarkistaa, söikö mato ruokaa viime siirron jälkeen. Jos syötiin,
   * paluuarvona true. Jos ei syöty, paluuarvona false.
   */
  public static boolean tarkistaRuoka(int[][] paikat, char[][] kentta) {
    // Käydään kenttätaulukko läpi ja etsitään ruuan sijainti.
    for (int rivi = 0; rivi < kentta.length; rivi++) {
      for (int sarake = 0; sarake < kentta[0].length; sarake++) {
        // Jos ruoka oli samassa paikassa missä madon pää, ruokaa syötiin.
        if (kentta[rivi][sarake] == RUOKA && rivi == paikat[0][0]
            && sarake == paikat[0][1])
          return true;
      }
    }
    // Ei syöty ruokaa.
    return false;
  }


  /* Laskee, montako reikää kentälle on tehty. Paluuarvo reikien lukumäärä,
   * joka on reuna-alkoiden lukumäärän ja seinien lukumäärän erotus.
   */
  public static int laskeMadonreikia(char[][] kentta) {
    // Apumuuttujat, joita vertaimella selvitetään reikien lukumäärä.
    int reunaAlkioidenLkm = 0;
    int seinienLkm = 0;
    
    // Lasketaan reuna-alkoiden lukumäärä. Käydään kenttätaulukko läpi.
    for (int rivi = 0; rivi < kentta.length; rivi++) {
      for (int sarake = 0; sarake < kentta[0].length; sarake++) {
        // Löydettiin reuna-alkio, lisätään se niiden lukumäärään.
        if (rivi == 0 || rivi == kentta.length - 1
            || sarake == 0 || sarake == kentta[0].length - 1)
          reunaAlkioidenLkm++;
      }
    }
    
    // Lasketaan seinien lukumäärä. Käydään kenttätaulukko läpi.
    for (int rivi = 0; rivi < kentta.length; rivi++) {
      for (int sarake = 0; sarake < kentta[0].length; sarake++) {
        // Löydettiin seinään tehty reikä, lisätään se niiden lukumäärään.
        if (kentta[rivi][sarake] == SEINA)
          seinienLkm++;
      }
    }
    
    // Vähennetään seinien lukumäärä reuna-alkoiden lukumäärästä.
    int reikienLkm = reunaAlkioidenLkm - seinienLkm;
    
    // Palautetaan reikien lukumäärä.
    return reikienLkm;
  }


  /* Tulostaa kaksiulotteisen taulukon kenttäalkiot näytölle.
   */
  public static void tulosta(char[][] kentta) {
    // Tulostetaan vain, jos taulukolle on varattu muistia.
    if (kentta != null) {
      // Tulostetaan taulukon alkiot.
      for (int rivi = 0; rivi < kentta.length; rivi++) {
        for (int sarake = 0; sarake < kentta[0].length; sarake++)
          System.out.print(kentta[rivi][sarake]);
        // Rivin lopussa vaihdetaan riviä.
        System.out.println();
      }
    }
  }


  /* Antaa madolle liikkumisohje valintasyötteen mukaan. Madon paikkatiedot
   * päivitetään valintaa vastaavaksi paikkataulukon arvoja muuttamalla. Madon
   * peruuttaminen ei ole sallittua. Paluuarvona on päivitetyt paikkatiedot.
   */
  public static int[][] liikutaMatoa(int[][] paikat, char valinta, char[][] kentta) {

    // Haluttiin liikkua johonkin suuntaan, eikä yritetty peruuttaa. Tehdään
    // perusteellinen tarkistus joka suunnalle.
    if ((valinta == LEFT && paikat[0][1] - 1 != paikat[1][1] &&
          paikat[1][1] - kentta[0].length + 1 != paikat[0][1]) ||
        (valinta == RIGHT && paikat[0][1] + 1 != paikat[1][1] &&
          paikat[0][1] - kentta[0].length + 1 != paikat[1][1]) ||
        (valinta == DOWN && paikat[0][0] + 1 != paikat[1][0] &&
          paikat[1][0] + kentta.length - 1 != paikat[0][0]) ||
        (valinta == UP && paikat[0][0] - 1 != paikat[1][0] &&
          paikat[0][0] + kentta.length - 1 != paikat[1][0])) {
      // Siirretään kaikkia madon osia paitsi päätä edellä olevaan paikkaan.
      for (int i = paikat.length - 1; i > 0; i--) {
        paikat[i][0] = paikat[i-1][0];
        paikat[i][1] = paikat[i-1][1];
      }

      // Siirretään madon päätä vasemmalle.
      if (valinta == LEFT) {
        // Jos pää menee yli vasemman laidan, se hyppää oikeaan laitaan.
        if (paikat[0][1] == 0)
          paikat[0][1] = kentta[0].length - 1;
        // Muutoin mato liikuu yhden askeleen vasemmalle.
        else
          paikat[0][1]--;
      }

      // Siirretään madon päätä oikealle.
      else if (valinta == RIGHT) {
        // Jos pää menee yli oikean laidan, se hyppää vasemaan laitaan.
        if (paikat[0][1] == kentta[0].length - 1)
          paikat[0][1] = 0;
        // Muutoin mato liikkuu yhden askeleen oikealle.
        else
          paikat[0][1]++;
      }

      // Siirretään madon päätä alaspäin.
      else if (valinta == DOWN) {
        // Jos pään menee yli alalaidan, se hyppää ylälaitaan.
        if (paikat[0][0] == kentta.length - 1)
          paikat[0][0] = 0;
        // Muutoin mato liikkuu yhden askeleen alas.
        else
          paikat[0][0]++;
      }

      // Siirretään madon päätä ylöspäin.
      else if (valinta == UP) {
        // Jos pää menee yli ylälaidan, se hyppää alalaitaan.
        if (paikat[0][0] == 0)
          paikat[0][0] = kentta.length - 1;
        // Muutoin mato liikkuu yhden askeleen ylös.
        else
          paikat[0][0]--;
      }
    }

    // Jos valinta oli suunnan vaihtaminen, muutetaan paikkatiedot käänteisiksi.
    if (valinta == SWAP) {
      // Muutetaan paikkatietoja sekä lopusta että alusta, lähestyen keskikohtaa.
      for (int i = 0; i < paikat.length / 2; i++) {
        // Tallennetaan lopusta lähtevän palan paikkatiedot.
        int lopustaRivi = paikat[i][0];
        int lopustaSarake = paikat[i][1];
        // Sijoitetaan lopusta lähtevälle palalle alusta lähtevän palan paikkatiedot.
        paikat[i][0] = paikat[paikat.length - i - 1][0];
        paikat[i][1] = paikat[paikat.length - i - 1][1];
        // Sijoitetaan alusta lähtevälle palalle lopusta lähtevän palan paikkatiedot.
        paikat[paikat.length - i - 1][0] = lopustaRivi;
        paikat[paikat.length - i - 1][1] = lopustaSarake;
      }
    }

    // Palautetaan päivitetty paikkataulukko main-metodiin.
    return paikat;
  }


  /* Tarkistaa, törmäsikö mato itseensä viime toiminnon jälkeen. Paluuarvo
   * on true jos ei törmännyt, false mikäli törmäsi.
   */
  public static boolean tarkistaTormays (int[][] paikat) {
    // Käydään madon muiden palasten paikkatiedot läpi ja verrataan niitä päähän.
    for (int paikanInd = 1; paikanInd < paikat.length; paikanInd++) {
      // Madon palasen paikkatiedot.
      int riviInd = paikat[paikanInd][0];
      int sarakeInd = paikat[paikanInd][1];
      
      // Jos palasella on samat paikkatiedot kuin päällä, mato kuolee.
      if (riviInd == paikat[0][0] && sarakeInd == paikat[0][1])
        return false;
    }

    // Ei törmätty. Mato selvisi hengissä.
    return true;
  }


  /* Kasvattaa matoa, mikäli mato söi viime siirrolla ruokaa. Luodaan uusi
   * paikkataulukko, jossa on yksi rivi enemmän paikkatietoja. Annetaan uudelle
   * riville hännän entisen sijainnin paikkatiedot. Paluuarvona paikkatiedot.
   */
  public static int[][] kasvataMatoa (int[][] paikat, int hantaRivi, int hantaSarake) {
    // Luodaan uusi, yhtä riviä pidempi, taulukko.
    int[][] pidennettyPaikat = new int[paikat.length + 1][2];
    
    // Kopioidaan vanhan paikkataulukon tiedot uuteen, pidempään paikkataulukkoon.
    for (int rivi = 0; rivi < paikat.length; rivi++) {
      for (int sarake = 0; sarake < paikat[0].length; sarake++)
        pidennettyPaikat[rivi][sarake] = paikat[rivi][sarake];
    }
    
    // Annetaan pidemmälle paikkataulukolle hännän edelliset paikkatiedot.
    pidennettyPaikat[paikat.length] = new int[] { hantaRivi, hantaSarake };
    
    // Palautetaan pidennetty mato main-metodiin.
    return pidennettyPaikat;
  }
}

